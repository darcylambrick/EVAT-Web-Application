# -*- coding: utf-8 -*-
"""Untitled23.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TDB-TjpY9iq3ww6wEGkYB78d0iMM8pcO
"""

import folium
from folium.plugins import MarkerCluster
import pandas as pd
from sklearn.cluster import KMeans
from geopy.distance import geodesic
import overpy
import sys
import numpy as np
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache

lat = sys.argv[1]
lon = sys.argv[2]
# chargerType = sys.argv[3]

print(lat)
print(lon)


# Cache size can be adjusted based on memory constraints and expected data reuse
@lru_cache(maxsize=1000)
def cached_amenities_query(lat, lon, radius=2000):
    api = overpy.Overpass()
    query = f"""
    (
      node["amenity"](around:{radius},{lat},{lon});
      way["amenity"](around:{radius},{lat},{lon});
      relation["amenity"](around:{radius},{lat},{lon});
    );
    out center;
    """
    result = api.query(query)
    amenities_list = []

    for node in result.nodes:
        point = node.tags
        point["id"] = node.id
        point["lat"] = float(node.lat)
        point["lon"] = float(node.lon)
        point["address"] = checkStreet(point)
        amenities_list.append(point)

    for way in result.ways:
        point = way.tags
        point["id"] = way.id
        point["lat"] = float(way.center_lat)
        point["lon"] = float(way.center_lon)
        point["address"] = checkStreet(point)
        amenities_list.append(point)

    for rel in result.relations:
        point = rel.tags
        point["id"] = rel.id
        point["lat"] = float(rel.center_lat)
        point["lon"] = float(rel.center_lon)
        point["address"] = checkStreet(point)
        amenities_list.append(point)

    return amenities_list

# Function to get nearby amenities
def get_amenities(gps_coordinates, radius=100):
    """Retrieves amenities from OSM at a given radius from multiple GPS points"""
    amenities_list = []
    queries = []

    # Prepare queries and cache results
    for coords in gps_coordinates:
        lat, lon = coords
        amenities = cached_amenities_query(lat, lon, radius)
        amenities_list.extend(amenities)

    return amenities_list

# Function to cluster the charging stations
def cluster_stations(df, n_clusters=25):
    # Extract the latitude and longitude for clustering
    coords = df[['latitude', 'longitude']].values

    # Initialize and fit KMeans with explicit n_init
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
    df.loc[:, 'cluster'] = kmeans.fit_predict(coords)  # Use .loc to avoid SettingWithCopyWarning

    return df, kmeans.cluster_centers_

# Function to find the closest N clusters
def find_nearest_clusters(user_location, cluster_centers, n_clusters_to_check=3):
    user_lat, user_lon = user_location
    distances = np.linalg.norm(cluster_centers - np.array([user_lat, user_lon]), axis=1)
    sorted_cluster_indices = np.argsort(distances)
    return sorted_cluster_indices[:n_clusters_to_check]

# Function to check street
def checkStreet(point):
    address = ""
    if "addr:housenumber" in point.keys() and "addr:street" in point.keys():
        address += f"{point['addr:housenumber']} {point['addr:street']}, "
    address += f"{point.get('addr:suburb', '')}, {point.get('addr:state', '')}"
    return address.strip(", ")

# Function to check for desired amenities
def check_amenities_nearby(coords, desired_amenities, radius=100):
    amenities_nearby = get_amenities([coords], radius)
    amenities_found = {amenity['amenity'] for amenity in amenities_nearby}
    return all(amenity in amenities_found for amenity in desired_amenities)

# Function to filter stations based on user preferences
def filter_stations(df, user_prefs):
    filtered_df = df

    if 'ispayatlocation' in user_prefs:
        filtered_df = filtered_df[filtered_df['UsageType.IsPayAtLocation'] == user_prefs['ispayatlocation']]

    if 'chargertype' in user_prefs:
        filtered_df = filtered_df[filtered_df['ConnectionType'] == user_prefs['chargertype']]

    if 'power' in user_prefs:
        filtered_df = filtered_df[filtered_df['Power'] >= user_prefs['power']]

    if 'currenttype' in user_prefs:
        filtered_df = filtered_df[filtered_df['CurrentType'] == user_prefs['currenttype']]

    if 'numberofpoints' in user_prefs:
        filtered_df = filtered_df[filtered_df['NumberOfPoints'] >= user_prefs['numberofpoints']]

    if 'amenities' in user_prefs:
        # Use parallel processing to speed up checking amenities
        with ThreadPoolExecutor() as executor:
            amenities_checks = list(executor.map(
                lambda row: check_amenities_nearby((row.latitude, row.longitude), user_prefs['amenities']),
                filtered_df.itertuples(index=False)
            ))
        filtered_df = filtered_df[amenities_checks]

    return filtered_df

# Function to find the nearest station
def find_nearest_station(user_location, df, user_prefs, cluster_centers):
    cluster_indices_to_check = find_nearest_clusters(user_location, cluster_centers)

    for cluster_idx in cluster_indices_to_check:
        # Filter stations within this cluster
        filtered_df = df[df['cluster'] == cluster_idx]
        filtered_df = filter_stations(filtered_df, user_prefs)

        # If matches are found, proceed to find the nearest station
        if not filtered_df.empty:
            # Calculate distances from user location to each station in the filtered list
            user_lat, user_lon = user_location
            station_coords = filtered_df[['latitude', 'longitude']].values
            distances = np.linalg.norm(station_coords - np.array([user_lat, user_lon]), axis=1)
            nearest_idx = np.argmin(distances)
            nearest_station = filtered_df.iloc[nearest_idx]
            return nearest_station

    # If no matches are found, provide user feedback or handle the case
    return None

# Visualization with Folium
def visualize_stations_folium(df, nearest_station, user_location, cluster_centers):
    # Create a Folium map centered at the user's location
    folium_map = folium.Map(location=user_location, zoom_start=12)

    # Add markers for each charging station, colored by cluster
    marker_cluster = MarkerCluster().add_to(folium_map)

    for idx, row in df.iterrows():
        folium.Marker(
            location=[row['latitude'], row['longitude']],
            popup=f"Operator: {row['operator']}\nCharger Type: {row['ConnectionType']}",
            icon=folium.Icon(color='green' if row['cluster'] != nearest_station['cluster'] else 'red')
        ).add_to(marker_cluster)

    # Add a marker for the nearest station
    if nearest_station is not None:
        folium.Marker(
            location=[nearest_station['latitude'], nearest_station['longitude']],
            popup=f"Nearest Station\\nOperator: {nearest_station['operator']}\\nCharger Type: {nearest_station['ConnectionType']}\\nNumberOfPoints: {nearest_station['NumberOfPoints']}",
            icon=folium.Icon(color='blue', icon='star')
        ).add_to(folium_map)

        # Add a polyline (route) from the user location to the nearest station
        folium.PolyLine(
            locations=[user_location, (nearest_station['latitude'], nearest_station['longitude'])],
            color='blue',
            weight=5,
            opacity=0.6
        ).add_to(folium_map)

    # Add a marker for the user's location
    folium.Marker(
        location=user_location,
        popup="User Location",
        icon=folium.Icon(color='orange', icon='user')
    ).add_to(folium_map)

    # Optional: Add cluster centers
    for center in cluster_centers:
        folium.Marker(
            location=[center[0], center[1]],
            icon=folium.Icon(color='black', icon='cloud')
        ).add_to(folium_map)

    # Display the map
    return folium_map

# Apply clustering to the DataFrame
df, cluster_centers = cluster_stations(df, n_clusters=20)

# Example user preferences
user_prefs = {
    'amenities': ['theatre'],
    'ConnectionType': ['Type1']
}

# Example user location
user_location = (lat, lon)  # Latitude and longitude of the user's location

# Find the nearest station
nearest_station = find_nearest_station(user_location, df, user_prefs, cluster_centers)

if nearest_station is not None:
    print("Nearest Station Details:")
    print(nearest_station[['latitude', 'longitude', 'operator', 'NumberOfPoints', 'ConnectionType', 'UsageType.IsPayAtLocation', 'Combined_Power_Output', 'UsageType.IsMembershipRequired', 'cost', 'StatusType.IsOperational']])

    # Fetch amenities near the nearest station
    station_location = [(nearest_station['latitude'], nearest_station['longitude'])]  # Wrap in a list
    amenities_near_station = get_amenities(station_location)

    print("\nNearby Amenities:")
    for amenity in amenities_near_station:
        print(amenity.get('name', 'Unnamed'), "-", amenity.get('address', 'Unknown Address'))

else:
    print("No matching charging stations found within the nearby clusters.")
    print("Consider relaxing some preferences or expanding the search radius.")

# Visualize the stations on the map
# folium_map = visualize_stations_folium(df, nearest_station, user_location, cluster_centers)
# folium_map.save('ev_charging_stations_map.html')  # Save to an HTML file
# folium_map

